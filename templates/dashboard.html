{% extends "falco_base.html" %}

{% block title %}Falco AI Alert System - Dashboard{% endblock %}
{% block page_icon %}<i class="fas fa-tachometer-alt"></i>{% endblock %}
{% block page_title %}Security Dashboard{% endblock %}
{% block page_description %}Real-time security monitoring with AI-powered analysis and intelligent alerting{% endblock %}

{% block extra_css %}
<style>
    /* Dashboard-specific layout */
    .dashboard-grid {
        display: flex;
        flex-direction: column;
        gap: var(--space-xl);
        min-height: calc(100vh - 180px);
    }

    /* Three Cards Grid Layout */
    .three-cards-grid {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: var(--space-lg);
        margin-bottom: var(--space-xl);
    }

    /* Filter Card - now uses same styling as other cards */
    .filter-card {
        background: var(--bg-cards);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        border: 2px solid var(--border-medium);
        border-top: 4px solid var(--falco-primary);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .filter-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
        border-color: var(--falco-primary-light);
        border-top-color: var(--falco-primary-dark);
    }

    .section-title {
        font-size: var(--text-lg);
        font-weight: 600;
        color: var(--text-heading);
        margin: 0;
        display: flex;
        align-items: center;
        gap: var(--space-sm);
    }

    .filter-group {
        margin-bottom: var(--space-lg);
    }

    .filter-group label {
        display: block;
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: var(--space-sm);
        font-size: var(--text-sm);
    }

    .filter-group select {
        width: 100%;
        border: 2px solid var(--border-light);
        border-radius: var(--radius-md);
        padding: var(--space-md);
        font-size: var(--text-sm);
        transition: border-color 0.2s ease;
        background: var(--falco-white);
    }

    .filter-group select:focus {
        border-color: var(--falco-primary);
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 174, 199, 0.1);
    }

    /* Alert Status Card */
    .alert-status-card {
        background: var(--bg-cards);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        border: 2px solid var(--border-medium);
        border-top: 4px solid var(--falco-accent);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .alert-status-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
        border-color: var(--falco-primary-light);
        border-top-color: var(--falco-accent);
    }

    .status-stats {
        display: flex;
        flex-direction: column;
        gap: var(--space-md);
        margin-bottom: var(--space-lg);
    }

    .status-item {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        font-size: var(--text-sm);
    }

    .status-badge {
        display: inline-flex;
        align-items: center;
        gap: var(--space-xs);
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        font-weight: 600;
        font-size: var(--text-xs);
        min-width: 2.5rem;
        justify-content: center;
    }

    .status-unread {
        background: rgba(239, 68, 68, 0.1);
        color: var(--danger);
        border: 1px solid rgba(239, 68, 68, 0.2);
    }

    .status-read {
        background: rgba(16, 185, 129, 0.1);
        color: var(--success);
        border: 1px solid rgba(16, 185, 129, 0.2);
    }

    .status-dismissed {
        background: rgba(107, 114, 128, 0.1);
        color: var(--text-muted);
        border: 1px solid rgba(107, 114, 128, 0.2);
    }

    .status-label {
        color: var(--text-primary);
        font-weight: 500;
    }

    .bulk-actions {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
    }

    .btn-bulk {
        background: var(--bg-secondary);
        border: 1px solid var(--border-light);
        color: var(--text-primary);
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: var(--text-xs);
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        justify-content: center;
    }

    .btn-bulk:hover {
        background: var(--primary-gradient);
        color: white;
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .btn-bulk:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    /* Main Content */
    .dashboard-main {
        background: transparent;
        padding: 0;
        overflow-y: auto;
        flex: 1;
    }

    /* Stats Grid */
    .stats-grid-main {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--space-xl);
        margin-bottom: var(--space-xl);
    }

    .stat-card {
        background: var(--primary-gradient);
        color: white;
        padding: var(--space-xl);
        border-radius: var(--radius-lg);
        text-align: center;
        box-shadow: var(--shadow-md);
        transition: transform 0.2s ease;
    }

    .stat-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    .stat-card.clickable {
        cursor: pointer;
    }

    .stat-card.danger {
        background: var(--danger-gradient);
    }

    .stat-card.success {
        background: var(--success-gradient);
    }

    .stat-card.status-card.unread {
        background: linear-gradient(135deg, #fef2f2, #fee2e2);
        color: var(--danger);
    }

    .stat-card.status-card.read {
        background: linear-gradient(135deg, #f0fdf4, #dcfce7);
        color: var(--success);
    }

    .stat-number {
        font-size: var(--text-4xl);
        font-weight: 700;
        margin-bottom: var(--space-sm);
    }

    .stat-label {
        font-size: var(--text-sm);
        opacity: 0.9;
    }

    /* Welcome Grid */
    .welcome-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: var(--space-xl);
        margin: var(--space-xl) 0;
    }

    .feature-card {
        background: var(--bg-card);
        border: 1px solid var(--border-light);
        border-radius: var(--radius-lg);
        padding: var(--space-xl);
        transition: all 0.3s ease;
        box-shadow: var(--shadow-sm);
    }

    .feature-card.clickable {
        cursor: pointer;
        position: relative;
        overflow: hidden;
    }

    .feature-card.clickable:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-xl);
        border-color: var(--falco-primary);
        background: linear-gradient(135deg, rgba(0, 174, 199, 0.05), rgba(0, 212, 170, 0.05));
    }

    .feature-card h4 {
        color: var(--falco-primary);
        margin-bottom: var(--space-lg);
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        font-size: var(--text-lg);
    }

    .feature-action {
        margin-top: var(--space-lg);
        padding: var(--space-md) var(--space-lg);
        background: var(--primary-gradient);
        color: white;
        border-radius: var(--radius-md);
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-sm);
    }

    .feature-card.clickable:hover .feature-action {
        background: linear-gradient(135deg, #00D4AA 0%, #00AEC7 100%);
        transform: scale(1.05);
    }

    /* ENHANCED ALERT LIST VISUAL INDICATORS */
    .alert-list {
        max-height: 400px;
        overflow-y: auto;
    }

    .alert-item {
        background: var(--bg-secondary);
        border: 1px solid var(--border-light);
        border-radius: var(--radius-md);
        padding: var(--space-lg);
        margin-bottom: var(--space-md);
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    /* Enhanced Unread Status */
    .alert-item.unread {
        border-left: 6px solid #ef4444;
        background: linear-gradient(90deg, 
            rgba(239, 68, 68, 0.08) 0%, 
            rgba(239, 68, 68, 0.02) 20%, 
            var(--bg-secondary) 40%);
        box-shadow: 
            0 2px 8px rgba(239, 68, 68, 0.15),
            inset 3px 0 0 rgba(239, 68, 68, 0.3);
        transform: translateX(2px);
    }

    .alert-item.unread::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, #ef4444, #dc2626);
        animation: unreadGlow 2s ease-in-out infinite;
    }

    .alert-item.unread::after {
        content: '●';
        position: absolute;
        top: 12px;
        right: 12px;
        color: #ef4444;
        font-size: 14px;
        animation: unreadPulse 2s ease-in-out infinite;
        text-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
    }

    /* Enhanced Read Status */
    .alert-item.read {
        border-left: 4px solid #10b981;
        background: linear-gradient(90deg, 
            rgba(16, 185, 129, 0.04) 0%, 
            rgba(16, 185, 129, 0.01) 15%, 
            var(--bg-secondary) 30%);
        opacity: 0.85;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .alert-item.read::before {
        content: '✓';
        position: absolute;
        top: 12px;
        right: 12px;
        color: #10b981;
        font-size: 12px;
        font-weight: bold;
        opacity: 0.7;
    }

    /* Enhanced Dismissed Status */
    .alert-item.dismissed {
        border-left: 4px solid #6b7280;
        background: linear-gradient(90deg, 
            rgba(107, 114, 128, 0.05) 0%, 
            rgba(107, 114, 128, 0.01) 15%, 
            var(--bg-secondary) 30%);
        opacity: 0.6;
        filter: grayscale(0.4);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
    }

    .alert-item.dismissed::before {
        content: '×';
        position: absolute;
        top: 12px;
        right: 12px;
        color: #6b7280;
        font-size: 14px;
        font-weight: bold;
        opacity: 0.6;
    }

    /* Hover Effects */
    .alert-item:hover {
        border-color: var(--falco-primary);
        background: rgba(0, 174, 199, 0.05);
        transform: translateY(-2px) translateX(4px);
        box-shadow: var(--shadow-lg);
    }

    .alert-item.unread:hover {
        border-left-color: #dc2626;
        background: linear-gradient(90deg, 
            rgba(239, 68, 68, 0.12) 0%, 
            rgba(239, 68, 68, 0.04) 20%, 
            rgba(0, 174, 199, 0.05) 40%);
        transform: translateY(-2px) translateX(6px);
        box-shadow: 
            0 4px 12px rgba(239, 68, 68, 0.2),
            var(--shadow-lg);
    }

    /* Selection State */
    .alert-item.selected {
        border-color: var(--falco-primary);
        background: rgba(0, 174, 199, 0.1);
        box-shadow: 
            0 0 0 2px rgba(0, 174, 199, 0.3),
            var(--shadow-lg);
        transform: translateY(-1px) translateX(3px);
    }

    /* Focus State for Keyboard Navigation */
    .alert-item.focused {
        border-color: var(--falco-primary);
        box-shadow: 
            0 0 0 3px rgba(0, 174, 199, 0.4),
            var(--shadow-md);
        outline: none;
    }

    /* Status Change Animation */
    .alert-item.status-changing {
        transition: all 0.5s ease;
        animation: statusChange 0.5s ease;
    }

    @keyframes statusChange {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
    }

    @keyframes unreadGlow {
        0%, 100% { opacity: 0.6; }
        50% { opacity: 1; }
    }

    @keyframes unreadPulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.3; transform: scale(1.1); }
    }

    /* Real-time Update Notification */
    .alert-item.newly-updated {
        animation: newUpdate 1s ease;
        border-color: var(--falco-primary);
    }

    @keyframes newUpdate {
        0% { 
            background: rgba(0, 174, 199, 0.2);
            transform: scale(1.02);
        }
        100% { 
            background: var(--bg-secondary);
            transform: scale(1);
        }
    }

    .alert-rule {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--space-md);
        font-size: var(--text-base);
        line-height: 1.3;
    }

    .alert-meta {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        font-size: var(--text-sm);
        color: var(--text-secondary);
        gap: var(--space-sm);
    }

    .alert-priority {
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        font-weight: 500;
        text-transform: uppercase;
        font-size: var(--text-xs);
        letter-spacing: 0.025em;
    }

    .priority-critical { background: var(--danger); color: white; box-shadow: var(--shadow-sm); }
    .priority-error { background: #ea580c; color: white; box-shadow: var(--shadow-sm); }
    .priority-warning { background: var(--warning); color: white; box-shadow: var(--shadow-sm); }
    .priority-notice { background: var(--info); color: white; box-shadow: var(--shadow-sm); }
    .priority-informational { background: var(--text-muted); color: white; box-shadow: var(--shadow-sm); }

    .alert-badge {
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        font-weight: 500;
        font-size: var(--text-xs);
        text-transform: uppercase;
        letter-spacing: 0.025em;
        display: inline-flex;
        align-items: center;
        gap: var(--space-xs);
    }

    .badge-ai-analyzed {
        background: var(--success);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .badge-ai-pending {
        background: var(--warning);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .badge-ai-error {
        background: var(--danger);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .badge-provider {
        background: var(--falco-primary);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .badge-source {
        background: var(--text-muted);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    /* Keyboard Shortcuts Indicator */
    .keyboard-shortcuts-hint {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: var(--text-xs);
        z-index: 9999;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
        pointer-events: none;
    }

    .keyboard-shortcuts-hint.show {
        opacity: 1;
        transform: translateY(0);
    }

    /* Real-time Status Updates */
    .real-time-indicator {
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--success);
        color: white;
        padding: var(--space-xs) var(--space-sm);
        border-radius: var(--radius-sm);
        font-size: var(--text-xs);
        z-index: 9998;
        display: flex;
        align-items: center;
        gap: var(--space-xs);
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
    }

    .real-time-indicator.connected {
        opacity: 1;
        transform: translateX(0);
    }

    .real-time-indicator.disconnected {
        background: var(--danger);
    }

    .real-time-indicator .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: currentColor;
        animation: pulse 2s ease-in-out infinite;
    }

    /* Config sections */
    .config-section {
        margin-bottom: var(--space-xl);
    }

    .config-value-container {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        margin-top: var(--space-sm);
    }

    .config-value {
        background: var(--bg-secondary);
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-light);
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: var(--text-sm);
        flex: 1;
        word-break: break-all;
    }

    .config-yaml-container {
        position: relative;
        margin-top: var(--space-sm);
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border-light);
        overflow: hidden;
    }

    .config-yaml {
        background: var(--bg-secondary);
        padding: var(--space-lg);
        border-radius: 0;
        border: none;
        font-family: 'Fira Code', 'Monaco', 'Menlo', 'Consolas', monospace;
        font-size: var(--text-sm);
        line-height: 1.5;
        margin: 0;
        white-space: pre;
        overflow-x: auto;
        color: var(--text-primary);
        tab-size: 2;
        -moz-tab-size: 2;
        -webkit-tab-size: 2;
        min-height: 300px;
    }

    .yaml-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-md) var(--space-lg);
        background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
        border-bottom: 1px solid var(--border-light);
        border-radius: var(--radius-md) var(--radius-md) 0 0;
        font-size: var(--text-sm);
    }

    .yaml-filename {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        font-family: 'Fira Code', 'Monaco', 'Menlo', 'Consolas', monospace;
        font-weight: 600;
        color: var(--text-primary);
    }

    .yaml-filename i {
        color: var(--falco-primary);
    }

    .yaml-header .btn {
        padding: var(--space-xs) var(--space-sm);
        font-size: var(--text-xs);
        border-color: var(--border-medium);
    }

    /* Collapsible sections */
    .collapsible-header {
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
        padding: var(--space-sm);
        border-radius: var(--radius-md);
    }

    .collapsible-header:hover {
        background: linear-gradient(135deg, rgba(0, 174, 199, 0.08), rgba(83, 86, 90, 0.08));
    }

    .card-title {
        width: 100%;
        display: flex;
        align-items: center;
        gap: var(--space-md);
    }

    .card-title .falco-config-toggle-icon,
    .card-title .card-toggle-icon {
        margin-left: auto;
    }

    .quick-stats-toggle-icon,
    .falco-config-toggle-icon,
    .card-toggle-icon {
        margin-left: auto;
        transition: transform 0.3s ease;
        color: var(--falco-primary);
        font-size: var(--text-sm);
    }

    #quickStatsCard.collapsed .quick-stats-content {
        display: none;
    }

    #quickStatsCard.collapsed .quick-stats-toggle-icon {
        transform: rotate(180deg);
    }

    #falcoConfigCard.collapsed .falco-config-content {
        display: none;
    }

    #falcoConfigCard.collapsed .falco-config-toggle-icon {
        transform: rotate(180deg);
    }

    #falcoIntegrationCard.collapsed .falco-config-content {
        display: none;
    }

    #falcoIntegrationCard.collapsed .falco-config-toggle-icon {
        transform: rotate(180deg);
    }

    /* Collapsed states for the three cards */
    #alertFiltersCard.collapsed .card-content {
        display: none;
    }

    #alertFiltersCard.collapsed .card-toggle-icon {
        transform: rotate(180deg);
    }

    #alertStatusCard.collapsed .card-content {
        display: none;
    }

    #alertStatusCard.collapsed .card-toggle-icon {
        transform: rotate(180deg);
    }

    #criticalStatsCard.collapsed .card-content {
        display: none;
    }

    #criticalStatsCard.collapsed .card-toggle-icon {
        transform: rotate(180deg);
    }

    .empty-state {
        text-align: center;
        padding: var(--space-2xl);
        color: var(--text-secondary);
    }

    .empty-state h3 {
        color: var(--text-primary);
        margin-bottom: var(--space-lg);
    }

    /* Loading states */
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }

    .spinner {
        display: inline-block;
        width: 1rem;
        height: 1rem;
        border: 2px solid transparent;
        border-top: 2px solid currentColor;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
        .three-cards-grid {
            grid-template-columns: 1fr;
            gap: var(--space-lg);
        }
        
        .stats-grid-main {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }
    }

    @media (max-width: 768px) {
        .three-cards-grid {
            grid-template-columns: 1fr;
            gap: var(--space-md);
        }
        
        .welcome-grid {
            grid-template-columns: 1fr;
        }
        
        .stats-grid-main {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        
        .alert-meta {
            flex-direction: column;
            align-items: flex-start;
        }
    }

    /* Filter Enhancements */
    .filter-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--space-md);
        margin-bottom: var(--space-md);
        align-items: end;
    }

    .filter-group.filter-actions {
        display: flex;
        gap: var(--space-sm);
        align-items: center;
        justify-content: flex-start;
    }

    .filter-input {
        width: 100%;
        padding: var(--space-sm);
        border: 2px solid var(--border-light);
        border-radius: var(--radius-sm);
        background: var(--bg-cards);
        color: var(--text-heading);
        font-size: var(--text-sm);
        transition: all 0.2s ease;
    }

    .filter-input:focus {
        outline: none;
        border-color: var(--falco-primary);
        box-shadow: 0 0 0 3px rgba(0, 174, 199, 0.1);
    }

    .filter-input::placeholder {
        color: var(--text-muted);
        opacity: 0.7;
    }

    .filters-status {
        display: flex;
        align-items: center;
        gap: var(--space-md);
    }

    .filter-count {
        font-size: var(--text-sm);
        color: var(--text-secondary);
        font-weight: 500;
        padding: var(--space-xs) var(--space-sm);
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-light);
    }

    .filter-count.active {
        background: var(--falco-primary);
        color: white;
        border-color: var(--falco-primary);
    }

    .btn-filter {
        background: var(--falco-primary);
        color: white;
        border: none;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-sm);
        font-size: var(--text-sm);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: var(--space-xs);
    }

    .btn-filter:hover {
        background: var(--falco-primary-dark);
        transform: translateY(-1px);
    }

    .btn-reset {
        background: var(--danger);
        color: white;
        border: none;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-sm);
        font-size: var(--text-sm);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: var(--space-xs);
    }

    .btn-reset:hover {
        background: var(--danger-dark);
        transform: translateY(-1px);
    }

    .btn-save-filter {
        background: var(--success);
        color: white;
        border: none;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-sm);
        font-size: var(--text-sm);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: var(--space-xs);
    }

    .btn-save-filter:hover {
        background: var(--success-dark);
        transform: translateY(-1px);
    }

    /* Enhanced filter selects */
    .filter-select {
        width: 100%;
        border: 2px solid var(--border-light);
        border-radius: var(--radius-sm);
        padding: var(--space-sm);
        font-size: var(--text-sm);
        transition: border-color 0.2s ease;
        background: var(--falco-white);
        color: var(--text-heading);
    }

    .filter-select:focus {
        border-color: var(--falco-primary);
        outline: none;
        box-shadow: 0 0 0 3px rgba(0, 174, 199, 0.1);
    }

    /* Filter state indicators */
    .filter-group.has-value .filter-label {
        color: var(--falco-primary);
        font-weight: 600;
    }

    .filter-group.has-value .filter-input,
    .filter-group.has-value .filter-select {
        border-color: var(--falco-primary);
        background: rgba(0, 174, 199, 0.05);
    }

    /* Filter responsiveness */
    @media (max-width: 768px) {
        .filter-row {
            grid-template-columns: 1fr;
            gap: var(--space-sm);
        }
        
        .filter-group.filter-actions {
            justify-content: center;
            margin-top: var(--space-md);
        }
        
        .filter-group.filter-actions button {
            flex: 1;
            max-width: 120px;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Real-time Status Indicator -->
<div class="real-time-indicator" id="realTimeIndicator">
    <div class="status-dot"></div>
    <span id="realTimeStatus">Connecting...</span>
</div>

<!-- Keyboard Shortcuts Hint -->
<div class="keyboard-shortcuts-hint" id="keyboardHint">
    <div><strong>Keyboard Shortcuts:</strong></div>
    <div>R - Mark as Read | D - Dismiss | ↑↓ - Navigate</div>
</div>

<div class="dashboard-grid">
    <!-- Falco Integration Setup (Collapsible) -->
    <div class="falco-card" id="falcoIntegrationCard">
        <div class="card-header collapsible-header" onclick="toggleFalcoIntegration()">
            <h3 class="card-title">
                <i class="fas fa-cog"></i>
                Falco Integration Setup
                <i class="fas fa-chevron-up falco-config-toggle-icon"></i>
            </h3>
        </div>
        <div class="card-body falco-config-content">
            <div class="empty-state">
                <div class="row">
                    <div class="col-12 mb-4">
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle"></i>
                            <strong>Configure Falco to send alerts to this system</strong><br>
                            Use the webhook URLs below in your Falco configuration to start receiving security alerts with AI analysis.
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="config-section">
                            <h5><i class="fas fa-link"></i> Webhook URLs</h5>
                            <p class="text-muted">Use these URLs to configure Falco HTTP output</p>
                            
                            <div class="mb-3">
                                <label class="fw-bold">🌐 External/Ingress URL:</label>
                                <div class="config-value-container">
                                    <input type="text" class="config-value" id="externalWebhookUrl" value="" readonly>
                                    <button class="btn btn-sm btn-outline" onclick="copyToClipboard('externalWebhookUrl')" title="Copy URL">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <small class="text-muted">Use this URL if Falco runs outside Kubernetes or you have external access configured</small>
                            </div>
                            
                            <div class="mb-3">
                                <label class="fw-bold">🏠 Internal/Kubernetes URL:</label>
                                <div class="config-value-container">
                                    <input type="text" class="config-value" id="internalWebhookUrl" value="" readonly>
                                    <button class="btn btn-sm btn-outline" onclick="copyToClipboard('internalWebhookUrl')" title="Copy URL">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline" onclick="toggleEnvironment()" title="Switch Environment" id="envToggleBtn">
                                        <i class="fas fa-sync-alt"></i>
                                    </button>
                                </div>
                                <small class="text-muted">Use this URL if Falco runs inside the same Kubernetes cluster</small>
                                <div class="mt-2">
                                    <small class="text-info">
                                        <i class="fas fa-info-circle"></i>
                                        Environment auto-detected. Click <i class="fas fa-sync-alt"></i> to switch between Production/Development URLs.
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6 mb-4">
                        <div class="config-section">
                            <h5><i class="fas fa-chart-line"></i> Test Webhook</h5>
                            <p class="text-muted">Send a test alert to verify configuration</p>
                            
                            <button class="btn btn-primary w-100" onclick="sendTestAlert()">
                                <i class="fas fa-paper-plane"></i>
                                Send Test Alert
                            </button>
                            
                            <div id="testResult" class="mt-3" style="display: none;"></div>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="config-section">
                            <h5><i class="fas fa-file-code"></i> Falco Configuration (YAML)</h5>
                            <p class="text-muted">Basic falco.yaml configuration for HTTP output</p>
                            
                            <div class="config-yaml-container">
                                <div class="yaml-header">
                                    <span class="yaml-filename">
                                        <i class="fas fa-file"></i>
                                        falco.yaml
                                    </span>
                                    <button class="btn btn-sm btn-outline" onclick="copyToClipboard('falcoYamlConfig')" title="Copy Configuration">
                                        <i class="fas fa-copy"></i>
                                        Copy
                                    </button>
                                </div>
                                <pre class="config-yaml" id="falcoYamlConfig">Loading...</pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6 mb-4">
                        <div class="config-section">
                            <h5><i class="fas fa-dharmachakra"></i> Kubernetes ConfigMap</h5>
                            <p class="text-muted">ConfigMap for Kubernetes deployment</p>
                            
                            <div class="config-yaml-container">
                                <div class="yaml-header">
                                    <span class="yaml-filename">
                                        <i class="fab fa-kubernetes"></i>
                                        falco-config.yaml
                                    </span>
                                    <button class="btn btn-sm btn-outline" onclick="copyToClipboard('falcoK8sConfig')" title="Copy Configuration">
                                        <i class="fas fa-copy"></i>
                                        Copy
                                    </button>
                                </div>
                                <pre class="config-yaml" id="falcoK8sConfig">Loading...</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three Card Layout -->
    <div class="three-cards-grid">
        <!-- Alert Filters Card -->
        <div class="filter-card" id="alertFiltersCard">
            <div class="card-header collapsible-header" onclick="toggleAlertFilters()">
                <h3 class="card-title">
                    <i class="fas fa-filter"></i>
                    Advanced Filters & Controls
                    <div class="filters-status">
                        <span id="filterStatus" class="filter-count">No filters active</span>
                        <i class="fas fa-chevron-up card-toggle-icon"></i>
                    </div>
                </h3>
            </div>
            <div class="card-body card-content">
                <!-- Primary Filters Row -->
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="timeRange">Time Range</label>
                        <select id="timeRange" class="filter-select" onchange="applyFilters()">
                            <option value="1h">Last Hour</option>
                            <option value="24h">Last 24 Hours</option>
                            <option value="7d" selected>Last 7 Days</option>
                            <option value="30d">Last 30 Days</option>
                            <option value="all">All Time</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="priorityFilter">Priority</label>
                        <select id="priorityFilter" class="filter-select" onchange="applyFilters()">
                            <option value="all">All Priorities</option>
                            <option value="critical">Critical</option>
                            <option value="error">Error</option>
                            <option value="warning">Warning</option>
                            <option value="notice">Notice</option>
                            <option value="info">Info</option>
                            <option value="debug">Debug</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="statusFilter">Status</label>
                        <select id="statusFilter" class="filter-select" onchange="applyFilters()">
                            <option value="all">All Status</option>
                            <option value="unread">Unread</option>
                            <option value="read">Read</option>
                            <option value="dismissed">Dismissed</option>
                            <option value="archived">Archived</option>
                        </select>
                    </div>
                </div>

                <!-- Secondary Filters Row -->
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="ruleFilter">Rule Name</label>
                        <input type="text" id="ruleFilter" class="filter-input" placeholder="Filter by rule name..." onchange="applyFilters()">
                    </div>
                    
                    <div class="filter-group">
                        <label for="containerFilter">Container</label>
                        <input type="text" id="containerFilter" class="filter-input" placeholder="Filter by container name..." onchange="applyFilters()">
                    </div>
                    
                    <div class="filter-group">
                        <label for="sourceFilter">Source/Host</label>
                        <input type="text" id="sourceFilter" class="filter-input" placeholder="Filter by source host..." onchange="applyFilters()">
                    </div>
                </div>

                <!-- Tertiary Filters Row -->
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="outputFilter">Alert Content</label>
                        <input type="text" id="outputFilter" class="filter-input" placeholder="Search in alert description..." onchange="applyFilters()">
                    </div>
                    
                    <div class="filter-group">
                        <label for="aiAnalysisFilter">AI Analysis</label>
                        <select id="aiAnalysisFilter" class="filter-select" onchange="applyFilters()">
                            <option value="all">All Alerts</option>
                            <option value="with_ai">With AI Analysis</option>
                            <option value="without_ai">Without AI Analysis</option>
                            <option value="ai_error">AI Analysis Failed</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="limitFilter">Show</label>
                        <select id="limitFilter" class="filter-select" onchange="applyFilters()">
                            <option value="25" selected>25 alerts</option>
                            <option value="50">50 alerts</option>
                            <option value="100">100 alerts</option>
                            <option value="200">200 alerts</option>
                            <option value="all">All alerts</option>
                        </select>
                    </div>
                </div>

                <!-- Actions Row -->
                <div class="filter-row">
                    <div class="filter-group filter-actions">
                        <button class="btn-filter" onclick="applyFilters()">
                            <i class="fas fa-search"></i> Apply
                        </button>
                        <button class="btn-reset" onclick="resetFilters()">
                            <i class="fas fa-times"></i> Reset
                        </button>
                        <button class="btn-save-filter" onclick="saveFilter()">
                            <i class="fas fa-bookmark"></i> Save
                        </button>
                    </div>
                    
                    <div class="filter-group bulk-actions">
                        <button class="btn-bulk" onclick="markAllAsRead()" title="Mark all visible alerts as read">
                            <i class="fas fa-check"></i> Mark All Read
                        </button>
                        <button class="btn-bulk" onclick="dismissAllVisible()" title="Dismiss all visible alerts">
                            <i class="fas fa-times"></i> Dismiss All
                        </button>
                    </div>
                    
                    <div class="filter-group">
                        <button class="btn-bulk" onclick="window.location.href='/runtime-events'" title="Open detailed Runtime Events view">
                            <i class="fas fa-external-link-alt"></i> Detailed View
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alert Status Card -->
        <div class="alert-status-card" id="alertStatusCard">
            <div class="card-header collapsible-header" onclick="toggleAlertStatus()">
                <h3 class="card-title">
                    <i class="fas fa-eye"></i>
                    Alert Status
                    <i class="fas fa-chevron-up card-toggle-icon"></i>
                </h3>
            </div>
            <div class="card-body card-content">
                <div class="status-stats">
                    <div class="status-item">
                        <span class="status-badge status-unread">
                            <i class="fas fa-circle"></i>
                            <span id="unreadCount">-</span>
                        </span>
                        <span class="status-label">Unread</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge status-read">
                            <i class="fas fa-check-circle"></i>
                            <span id="readCount">-</span>
                        </span>
                        <span class="status-label">Read</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge status-dismissed">
                            <i class="fas fa-times-circle"></i>
                            <span id="dismissedCount">-</span>
                        </span>
                        <span class="status-label">Dismissed</span>
                    </div>
                </div>
                
                <div class="bulk-actions">
                    <button class="btn-bulk" onclick="markVisibleAsRead()" title="Mark visible alerts as read">
                        <i class="fas fa-check"></i>
                        Mark Visible Read
                    </button>
                    <button class="btn-bulk" onclick="markAllAsRead()" title="Mark ALL alerts as read">
                        <i class="fas fa-check-double"></i>
                        Mark All Read
                    </button>
                    <button class="btn-bulk" onclick="dismissAllVisible()" title="Dismiss all visible alerts">
                        <i class="fas fa-times"></i>
                        Dismiss Visible
                    </button>
                </div>
            </div>
        </div>

        <!-- Critical Stats Card -->
        <div class="alert-status-card" id="criticalStatsCard">
            <div class="card-header collapsible-header" onclick="toggleCriticalStats()">
                <h3 class="card-title">
                    <i class="fas fa-chart-line"></i>
                    Critical Stats
                    <i class="fas fa-chevron-up card-toggle-icon"></i>
                </h3>
            </div>
            <div class="card-body card-content">
                <div class="status-stats">
                    <div class="status-item">
                        <span class="status-badge status-unread">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span id="criticalCountControl">-</span>
                        </span>
                        <span class="status-label">Critical</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge status-read">
                            <i class="fas fa-clock"></i>
                            <span id="recentCountControl">-</span>
                        </span>
                        <span class="status-label">Last Hour</span>
                    </div>
                    <div class="status-item">
                        <span class="status-badge status-dismissed">
                            <i class="fas fa-shield-alt"></i>
                            <span id="totalCountControl">-</span>
                        </span>
                        <span class="status-label">Total</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="dashboard-main">

        <!-- Welcome/Overview -->
        <div class="falco-card" id="welcomeCard">
            <div class="card-header">
                <h3 class="card-title">
                    <i class="fas fa-home"></i>
                    Welcome to Falco AI Alert System
                </h3>
            </div>
            <div class="card-body">
                <div class="empty-state">
                    <p>Your intelligent security monitoring dashboard is ready to help you stay ahead of threats.</p>
                    
                    <div class="alert alert-info mb-4">
                        <i class="fas fa-info-circle"></i>
                        <strong>Getting Started:</strong> Click to expand the <strong>Falco Integration Setup</strong> section at the top to configure Falco webhooks and start receiving AI-powered security analysis.
                    </div>
                    
                    <div class="welcome-grid">
                        <div class="feature-card">
                            <h4><i class="fas fa-shield-alt"></i> Real-time Monitoring</h4>
                            <p>Monitor security events from Falco with AI-powered analysis and intelligent alerting.</p>
                        </div>
                        <div class="feature-card clickable" onclick="window.location.href='/enhanced-chat'">
                            <h4><i class="fas fa-robot"></i> AI Security Command Center</h4>
                            <p>Central AI-powered security management with persona-based analysis, semantic search, and dynamic report generation.</p>
                            <div class="feature-action">
                                <i class="fas fa-arrow-right"></i> Launch Command Center
                            </div>
                        </div>
                        <div class="feature-card clickable" onclick="window.location.href='/chat'">
                            <h4><i class="fas fa-comments"></i> AI Security Chat</h4>
                            <p>Chat with AI about security alerts in real-time. Ask questions, get insights, and understand threats better.</p>
                            <div class="feature-action">
                                <i class="fas fa-arrow-right"></i> Start Chatting
                            </div>
                        </div>
                        <div class="feature-card">
                            <h4><i class="fas fa-brain"></i> AI Analysis</h4>
                            <p>Get instant security insights and recommendations powered by advanced AI models.</p>
                        </div>
                        <div class="feature-card">
                            <h4><i class="fab fa-slack"></i> Slack Integration</h4>
                            <p>Receive critical alerts directly in Slack with actionable intelligence.</p>
                        </div>
                        <div class="feature-card clickable" onclick="window.location.href='/weaviate-analytics'">
                            <h4><i class="fas fa-chart-line"></i> AI-Powered Analytics</h4>
                            <p>Advanced ML-driven clustering, threat intelligence, and semantic search with real-time insights.</p>
                            <div class="feature-action">
                                <i class="fas fa-arrow-right"></i> Launch Analytics
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Stats -->
        <div class="falco-card" id="quickStatsCard" style="display: none;">
            <div class="card-header collapsible-header" onclick="toggleQuickStats()">
                <h3 class="card-title">
                    <i class="fas fa-chart-bar"></i>
                    Quick Stats
                    <i class="fas fa-chevron-up quick-stats-toggle-icon"></i>
                </h3>
            </div>
            <div class="card-body quick-stats-content">
                <div class="stats-grid-main">
                    <div class="stat-card clickable" onclick="applyStatFilter('all', event)" title="Show all alerts">
                        <div class="stat-number" id="totalAlertsMain">-</div>
                        <div class="stat-label" data-translate="Total Alerts">Total Alerts</div>
                    </div>
                    <div class="stat-card danger clickable" onclick="applyStatFilter('critical', event)" title="Show critical alerts">
                        <div class="stat-number" id="criticalAlertsMain">-</div>
                        <div class="stat-label" data-translate="Critical Alerts">Critical Alerts</div>
                    </div>
                    <div class="stat-card success clickable" onclick="applyStatFilter('recent', event)" title="Show alerts from last hour">
                        <div class="stat-number" id="recentAlertsMain">-</div>
                        <div class="stat-label" data-translate="Last Hour">Last Hour</div>
                    </div>
                    <div class="stat-card status-card unread clickable" onclick="applyStatFilter('unread', event)" title="Show unread alerts">
                        <div class="stat-number" id="unreadCountMain">-</div>
                        <div class="stat-label" data-translate="Unread">Unread</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alert List -->
        <div class="falco-card" id="alertsCard" style="display: none;">
            <div class="card-header">
                <h3 class="card-title">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span data-translate="Recent Security Alerts">Recent Security Alerts</span>
                    <span class="badge bg-primary" id="alertCountBadge">0</span>
                </h3>
            </div>
            <div class="card-body">
                <div class="alert-list" id="alertList">
                    <!-- Alerts will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
    // Global variables
    let alerts = [];
    let filteredAlerts = [];
    let focusedAlertIndex = -1;
    let eventSource = null;
    let realTimeConnected = false;
    let currentFilters = {
        timeRange: '7d',
        priority: 'all',
        rule: '',
        status: 'all',
        limit: '25',
        container: '',
        source: '',
        output: '',
        aiAnalysis: 'all'
    };
    let alertStats = {
        total: 0,
        unread: 0,
        read: 0,
        dismissed: 0,
        critical: 0,
        recent: 0
    };

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Read URL parameters and set filters
        initializeFiltersFromURL();
        
        // Generate webhook URLs
        generateWebhookUrls();
        
        // Load alerts with filters
        loadAlerts();
        
        // Load alert counts
        loadAlertCounts();
        
        // Set up keyboard shortcuts
        setupKeyboardShortcuts();
        
        // Initialize real-time updates
        initializeRealTimeUpdates();
        
        // Set up periodic refresh (fallback for SSE)
        setInterval(loadAlerts, 30000); // Refresh every 30 seconds
        setInterval(loadAlertCounts, 30000);
        
        // Show keyboard shortcuts hint initially
        showKeyboardHint();
    });

    // Initialize filters from URL parameters
    function initializeFiltersFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        
        // Set time range filter
        const timeRange = urlParams.get('time_range') || '7d';
        const timeRangeSelect = document.getElementById('timeRange');
        if (timeRangeSelect && timeRange !== '7d') {
            timeRangeSelect.value = timeRange;
            currentFilters.timeRange = timeRange;
        }
        
        // Set priority filter
        const priority = urlParams.get('priority') || 'all';
        const prioritySelect = document.getElementById('priorityFilter');
        if (prioritySelect && priority !== 'all') {
            prioritySelect.value = priority;
            currentFilters.priority = priority;
        }
        
        // Set rule filter
        const rule = urlParams.get('rule') || '';
        const ruleInput = document.getElementById('ruleFilter');
        if (ruleInput && rule) {
            ruleInput.value = rule;
            currentFilters.rule = rule;
        }
        
        // Set status filter
        const status = urlParams.get('status') || 'all';
        const statusSelect = document.getElementById('statusFilter');
        if (statusSelect && status !== 'all') {
            statusSelect.value = status;
            currentFilters.status = status;
        }
        
        // Set limit filter
        const limit = urlParams.get('limit') || '25';
        const limitSelect = document.getElementById('limitFilter');
        if (limitSelect && limit !== '25') {
            limitSelect.value = limit;
            currentFilters.limit = limit;
        }
        
        // Set container filter
        const container = urlParams.get('container') || '';
        const containerInput = document.getElementById('containerFilter');
        if (containerInput && container) {
            containerInput.value = container;
            currentFilters.container = container;
        }
        
        // Set source filter
        const source = urlParams.get('source') || '';
        const sourceInput = document.getElementById('sourceFilter');
        if (sourceInput && source) {
            sourceInput.value = source;
            currentFilters.source = source;
        }
        
        // Set output filter
        const output = urlParams.get('output') || '';
        const outputInput = document.getElementById('outputFilter');
        if (outputInput && output) {
            outputInput.value = output;
            currentFilters.output = output;
        }
        
        // Set AI analysis filter
        const aiAnalysis = urlParams.get('ai_analysis') || 'all';
        const aiAnalysisSelect = document.getElementById('aiAnalysisFilter');
        if (aiAnalysisSelect && aiAnalysis !== 'all') {
            aiAnalysisSelect.value = aiAnalysis;
            currentFilters.aiAnalysis = aiAnalysis;
        }
    }

    // Load alerts with current filters
    async function loadAlerts() {
        try {
            console.log('Loading alerts for Dashboard...');
            // Fetch all alerts and let client-side filtering handle the work
            const response = await fetch('/api/alerts?limit=1000');
            
            if (response.ok) {
                alerts = await response.json();
                console.log(`✅ Loaded ${alerts.length} alerts for Dashboard`);
                
                // Apply filters and update display
                applyFilters();
            } else {
                console.error('Failed to load alerts:', response.statusText);
            }
        } catch (error) {
            console.error('Error loading alerts:', error);
        }
    }

    // Update page title based on active filters
    function updatePageTitle() {
        let title = 'Security Dashboard';
        const activeFilters = [];
        
        if (currentFilters.priority !== 'all') {
            activeFilters.push(`${currentFilters.priority} priority`);
        }
        if (currentFilters.rule) {
            activeFilters.push(`rule: ${currentFilters.rule}`);
        }
        if (currentFilters.status !== 'all') {
            activeFilters.push(`${currentFilters.status} status`);
        }
        if (currentFilters.timeRange !== '7d') {
            activeFilters.push(`${currentFilters.timeRange} timeframe`);
        }
        if (currentFilters.container) {
            activeFilters.push(`container: ${currentFilters.container}`);
        }
        if (currentFilters.source) {
            activeFilters.push(`source: ${currentFilters.source}`);
        }
        if (currentFilters.output) {
            activeFilters.push(`content: ${currentFilters.output}`);
        }
        if (currentFilters.aiAnalysis !== 'all') {
            activeFilters.push(`AI: ${currentFilters.aiAnalysis}`);
        }
        
        if (activeFilters.length > 0) {
            title += ` - ${activeFilters.join(', ')}`;
        }
        
        document.title = title;
        
        // Update the page header to show active filters
        const pageDescription = document.querySelector('.page-description');
        if (pageDescription) {
            if (activeFilters.length > 0) {
                pageDescription.textContent = `Filtered by: ${activeFilters.join(', ')}`;
            } else {
                pageDescription.textContent = 'Real-time security monitoring with AI-powered analysis and intelligent alerting';
            }
        }
    }

    // Apply current filters to alerts
    function applyFilters() {
        // Update current filters from form elements
        currentFilters.timeRange = document.getElementById('timeRange')?.value || '7d';
        currentFilters.priority = document.getElementById('priorityFilter')?.value || 'all';
        currentFilters.rule = document.getElementById('ruleFilter')?.value || '';
        currentFilters.status = document.getElementById('statusFilter')?.value || 'all';
        currentFilters.limit = document.getElementById('limitFilter')?.value || '25';
        currentFilters.container = document.getElementById('containerFilter')?.value || '';
        currentFilters.source = document.getElementById('sourceFilter')?.value || '';
        currentFilters.output = document.getElementById('outputFilter')?.value || '';
        currentFilters.aiAnalysis = document.getElementById('aiAnalysisFilter')?.value || 'all';
        
        console.log('🔍 Dashboard filters applied:', currentFilters);
        
        filteredAlerts = alerts.filter(alert => {
            if (!alert) return false;

            // Time range filter
            if (currentFilters.timeRange !== 'all') {
                const alertTime = new Date(alert.timestamp || alert.time);
                if (isNaN(alertTime.getTime())) {
                    return false; // Skip alerts with invalid timestamps
                }
                
                const now = new Date();
                const diffHours = (now - alertTime) / (1000 * 60 * 60);
                
                switch (currentFilters.timeRange) {
                    case '1h': if (diffHours > 1) return false; break;
                    case '24h': if (diffHours > 24) return false; break;
                    case '7d': if (diffHours > 24 * 7) return false; break;
                    case '30d': if (diffHours > 24 * 30) return false; break;
                }
            }

            // Priority filter
            if (currentFilters.priority !== 'all') {
                const alertPriority = alert.priority || 'info';
                if (alertPriority !== currentFilters.priority) {
                    return false;
                }
            }

            // Status filter  
            if (currentFilters.status !== 'all') {
                const alertStatus = alert.status || 'unread';
                if (alertStatus !== currentFilters.status) {
                    return false;
                }
            }

            // Rule filter
            if (currentFilters.rule) {
                const alertRule = alert.rule || '';
                if (!alertRule.toLowerCase().includes(currentFilters.rule.toLowerCase())) {
                    return false;
                }
            }

            // Container filter
            if (currentFilters.container) {
                const containerName = alert.source || 
                                    alert.fields?.['container.name'] || 
                                    alert.output_fields?.['container.name'] || '';
                if (!containerName.toLowerCase().includes(currentFilters.container.toLowerCase())) {
                    return false;
                }
            }

            // Source filter
            if (currentFilters.source) {
                const source = alert.source || '';
                if (!source.toLowerCase().includes(currentFilters.source.toLowerCase())) {
                    return false;
                }
            }

            // Output content filter
            if (currentFilters.output) {
                const output = alert.output || '';
                if (!output.toLowerCase().includes(currentFilters.output.toLowerCase())) {
                    return false;
                }
            }

            // AI Analysis filter
            if (currentFilters.aiAnalysis !== 'all') {
                const hasAI = alert.ai_analysis && Object.keys(alert.ai_analysis).length > 0;
                const hasAIError = alert.ai_analysis && alert.ai_analysis.error;
                
                switch (currentFilters.aiAnalysis) {
                    case 'with_ai':
                        if (!hasAI || hasAIError) return false;
                        break;
                    case 'without_ai':
                        if (hasAI && !hasAIError) return false;
                        break;
                    case 'ai_error':
                        if (!hasAIError) return false;
                        break;
                }
            }

            return true;
        });
        
        // Apply limit
        if (currentFilters.limit !== 'all') {
            const limit = parseInt(currentFilters.limit);
            filteredAlerts = filteredAlerts.slice(0, limit);
        }
        
        // Update display
        updateStats();
        updateDisplay();
        updateFilterStatus();
        updatePageTitle();
        updateURLParameters();
        
        console.log(`✅ Dashboard filtering complete: ${filteredAlerts.length} of ${alerts.length} alerts shown`);
    }

    // Update statistics
    function updateStats() {
        alertStats = {
            total: alerts.length,
            unread: alerts.filter(a => a.status === 'unread').length,
            read: alerts.filter(a => a.status === 'read').length,
            dismissed: alerts.filter(a => a.status === 'dismissed').length,
            critical: alerts.filter(a => a.priority === 'critical').length,
            recent: alerts.filter(a => {
                const alertTime = new Date(a.time);
                const now = new Date();
                return (now - alertTime) / (1000 * 60 * 60) <= 1;
            }).length
        };
        
        updateStatElements();
    }

    // Update stat display elements
    function updateStatElements() {
        const elements = {
            'totalAlertsMain': alertStats.total,
            'criticalAlertsMain': alertStats.critical,
            'recentAlertsMain': alertStats.recent,
            'unreadCountMain': alertStats.unread,
            'unreadCount': alertStats.unread,
            'readCount': alertStats.read,
            'dismissedCount': alertStats.dismissed,
            'criticalCountControl': alertStats.critical,
            'recentCountControl': alertStats.recent,
            'totalCountControl': alertStats.total
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });
        
        const alertCountBadge = document.getElementById('alertCountBadge');
        if (alertCountBadge) {
            alertCountBadge.textContent = filteredAlerts.length;
        }
    }

    // Update display based on alerts
    function updateDisplay() {
        if (alerts.length === 0) {
            showWelcomeState();
        } else {
            showAlertsState();
            renderAlertList();
            populateRuleFilter();
        }
    }

    // Show welcome state (no alerts)
    function showWelcomeState() {
        document.getElementById('welcomeCard').style.display = 'block';
        document.getElementById('quickStatsCard').style.display = 'none';
        document.getElementById('alertsCard').style.display = 'none';
    }

    // Show alerts state (has alerts)
    function showAlertsState() {
        document.getElementById('welcomeCard').style.display = 'none';
        document.getElementById('quickStatsCard').style.display = 'block';
        document.getElementById('alertsCard').style.display = 'block';
    }

    // Render alert list
    function renderAlertList() {
        const alertList = document.getElementById('alertList');
        if (!alertList) return;
        
        if (filteredAlerts.length === 0) {
            alertList.innerHTML = '<div class="empty-state"><h4>No alerts match your current filters</h4><p>Try adjusting your filter criteria to see more results.</p></div>';
            return;
        }
        
        alertList.innerHTML = filteredAlerts.map((alert, index) => `
            <div class="alert-item ${alert.status || 'unread'}" 
                 onclick="selectAlert('${alert.id}')" 
                 data-alert-id="${alert.id}" 
                 data-alert-index="${index}"
                 tabindex="0">
                <div class="alert-rule">${escapeHtml(alert.rule)}</div>
                <div class="alert-meta">
                    <div>
                        <span class="alert-priority priority-${alert.priority}">${alert.priority}</span>
                        ${alert.ai_analysis ? '<span class="alert-badge badge-ai-analyzed">AI Analyzed</span>' : '<span class="alert-badge badge-ai-pending">AI Pending</span>'}
                        <span class="alert-badge badge-provider">${alert.provider || 'Falco'}</span>
                    </div>
                    <div>
                        <small>${formatTimestamp(alert.time)}</small>
                    </div>
                </div>
            </div>
        `).join('');
        
        // Reset focused index when re-rendering
        focusedAlertIndex = -1;
        updateAlertFocus();
    }

    // Toggle functions (removed control panel)

    function toggleQuickStats() {
        const card = document.getElementById('quickStatsCard');
        card.classList.toggle('collapsed');
    }

    function toggleFalcoIntegration() {
        const card = document.getElementById('falcoIntegrationCard');
        card.classList.toggle('collapsed');
    }

    function toggleAlertFilters() {
        const card = document.getElementById('alertFiltersCard');
        card.classList.toggle('collapsed');
    }

    function toggleAlertStatus() {
        const card = document.getElementById('alertStatusCard');
        card.classList.toggle('collapsed');
    }

    function toggleCriticalStats() {
        const card = document.getElementById('criticalStatsCard');
        card.classList.toggle('collapsed');
    }

    // Webhook URL generation with environment detection
    function generateWebhookUrls() {
        const protocol = window.location.protocol;
        const host = window.location.host;
        const externalUrl = `${protocol}//${host}/falco-webhook`;
        
        // Detect environment based on various indicators (or use override)
        const isProduction = environmentOverride !== null ? environmentOverride : detectEnvironment();
        const internalUrl = generateInternalWebhookUrl(isProduction);
        
        // Debug: Log environment detection
        console.log(`🔍 Environment Detection: ${isProduction ? 'Production' : 'Development'}`, {
            hostname: window.location.hostname,
            port: window.location.port,
            protocol: window.location.protocol
        });
        
        document.getElementById('externalWebhookUrl').value = externalUrl;
        document.getElementById('internalWebhookUrl').value = internalUrl;
        
        // Update UI labels to show detected environment
        updateEnvironmentLabels(isProduction);
        
        generateFalcoConfig(externalUrl, internalUrl, isProduction);
    }

    // Detect if running in production or development environment
    function detectEnvironment() {
        // Check multiple indicators to determine environment
        const hostname = window.location.hostname;
        const port = window.location.port;
        const pathname = window.location.pathname;
        
        // Production indicators
        if (hostname.includes('prod') || 
            hostname.includes('production') ||
            (port !== '8080' && port !== '3000' && port !== '') ||
            hostname.match(/^[^.]+\.[^.]+\.[^.]+$/)) { // Domain with TLD
            return true;
        }
        
        // Development indicators
        if (hostname === 'localhost' || 
            hostname === '127.0.0.1' ||
            hostname.includes('dev') ||
            hostname.includes('development') ||
            port === '8080' || 
            port === '3000') {
            return false;
        }
        
        // Default to production for safety
        return true;
    }

    // Generate environment-appropriate internal webhook URL
    function generateInternalWebhookUrl(isProduction) {
        if (isProduction) {
            return 'http://prod-falco-ai-alerts.falco-ai-alerts.svc.cluster.local:8080/falco-webhook';
        } else {
            return 'http://dev-falco-ai-alerts.falco-ai-alerts-dev.svc.cluster.local:8080/falco-webhook';
        }
    }

    // Update UI labels to show detected environment
    function updateEnvironmentLabels(isProduction) {
        const environmentBadge = isProduction ? 
            '<span class="badge bg-success ms-2">Production</span>' : 
            '<span class="badge bg-warning ms-2">Development</span>';
        
        // Update internal URL label
        const internalLabel = document.querySelector('label[class="fw-bold"]:nth-of-type(2)');
        if (internalLabel) {
            internalLabel.innerHTML = `🏠 Internal/Kubernetes URL: ${environmentBadge}`;
        }
        
        // Update description text
        const internalDescription = internalLabel?.parentElement?.querySelector('small');
        if (internalDescription) {
            const envContext = isProduction ? 
                'production (prod-) services in falco-ai-alerts namespace' : 
                'development (dev-) services in falco-ai-alerts-dev namespace';
            internalDescription.innerHTML = `Use this URL if Falco runs inside the same Kubernetes cluster (targets ${envContext})`;
        }
    }

    // Global variable to track current environment override
    let environmentOverride = null;

    // Toggle between production and development environment URLs
    function toggleEnvironment() {
        const currentlyProduction = environmentOverride !== null ? environmentOverride : detectEnvironment();
        const newEnvironment = !currentlyProduction;
        
        // Set override
        environmentOverride = newEnvironment;
        
        // Regenerate URLs with new environment
        const protocol = window.location.protocol;
        const host = window.location.host;
        const externalUrl = `${protocol}//${host}/falco-webhook`;
        const internalUrl = generateInternalWebhookUrl(newEnvironment);
        
        document.getElementById('internalWebhookUrl').value = internalUrl;
        updateEnvironmentLabels(newEnvironment);
        generateFalcoConfig(externalUrl, internalUrl, newEnvironment);
        
        console.log(`🔄 Environment switched to: ${newEnvironment ? 'Production' : 'Development'} (manual override)`);
    }

    // Generate Falco configuration with environment context
    function generateFalcoConfig(externalUrl, internalUrl, isProduction) {
        const environmentLabel = isProduction ? 'Production' : 'Development';
        const namespaceLabel = isProduction ? 'falco-ai-alerts' : 'falco-ai-alerts-dev';
        const falcoYaml = `# Falco Configuration (falco.yaml) - ${environmentLabel} Environment
# Add this to your existing falco.yaml configuration file

http_output:
  enabled: true
  url: ${externalUrl}
  user_agent: "falco/0.34.0"
  # Optional: Add custom headers if needed
  # custom_headers:
  #   Authorization: "Bearer your-token-here"

# Enable JSON output for structured alerts
json_output: true
json_include_output_property: true
json_include_tags_property: true

# Optional: Configure buffering for better performance
buffered_outputs: true

# Optional: Set output priority threshold
priority: debug`;

        const falcoK8sConfig = `# Kubernetes ConfigMap for Falco Configuration - ${environmentLabel} Environment
# Apply this with: kubectl apply -f falco-config.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-config
  namespace: falco
  labels:
    app: falco
    component: config
    environment: ${isProduction ? 'production' : 'development'}
data:
  falco.yaml: |
    # HTTP Output Configuration - ${environmentLabel} Environment
    http_output:
      enabled: true
      url: ${internalUrl}
      user_agent: "falco/0.34.0"
      # Target: ${namespaceLabel} namespace
      # Use internal service name for in-cluster communication
      # custom_headers:
      #   Authorization: "Bearer your-token-here"
    
    # JSON Output Settings
    json_output: true
    json_include_output_property: true
    json_include_tags_property: true
    
    # Performance Settings
    buffered_outputs: true
    priority: debug
    
    # Optional: Configure additional outputs
    # stdout_output:
    #   enabled: false
    # 
    # file_output:
    #   enabled: false`;

        document.getElementById('falcoYamlConfig').textContent = falcoYaml;
        document.getElementById('falcoK8sConfig').textContent = falcoK8sConfig;
    }

    // Utility functions
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diffMinutes = Math.floor((now - date) / (1000 * 60));
        
        if (diffMinutes < 1) return 'Just now';
        if (diffMinutes < 60) return `${diffMinutes}m ago`;
        
        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) return `${diffHours}h ago`;
        
        const diffDays = Math.floor(diffHours / 24);
        if (diffDays < 7) return `${diffDays}d ago`;
        
        return date.toLocaleDateString();
    }

    // Refresh dashboard
    function refreshDashboard() {
        loadAlerts();
    }

    // Copy to clipboard
    function copyToClipboard(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
            let textToCopy = '';
            
            // Handle different element types
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.select();
                textToCopy = element.value;
            } else if (element.tagName === 'PRE') {
                textToCopy = element.textContent;
            } else {
                textToCopy = element.innerText || element.textContent;
            }
            
            // Use modern clipboard API if available
            if (navigator.clipboard) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showNotification('success', 'Configuration copied to clipboard!');
                }).catch(() => {
                    // Fallback to execCommand
                    fallbackCopyToClipboard(textToCopy);
                });
            } else {
                fallbackCopyToClipboard(textToCopy);
            }
        }
    }
    
    function fallbackCopyToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showNotification('success', 'Configuration copied to clipboard!');
        } catch (err) {
            showNotification('error', 'Failed to copy to clipboard');
        }
        document.body.removeChild(textArea);
    }
    
    function showNotification(type, message) {
        // Simple notification - can be enhanced with a proper notification system
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: ${type === 'success' ? '#10b981' : '#ef4444'};
            color: white;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 9999;
            font-size: 14px;
            font-weight: 500;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }

    // Test alert
    async function sendTestAlert() {
        try {
            const response = await fetch('/api/test-alert', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const result = document.getElementById('testResult');
            result.style.display = 'block';
            
            if (response.ok) {
                result.innerHTML = '<div class="alert alert-success"><i class="fas fa-check-circle"></i> Test alert sent successfully!</div>';
                setTimeout(loadAlerts, 2000);
            } else {
                throw new Error('Failed to send test alert');
            }
        } catch (error) {
            const result = document.getElementById('testResult');
            result.style.display = 'block';
            result.innerHTML = `<div class="alert alert-danger"><i class="fas fa-exclamation-triangle"></i> Error: ${error.message}</div>`;
        }
    }

    // Select alert
    async function selectAlert(alertId) {
        document.querySelectorAll('.alert-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        
        const alertItem = document.querySelector(`[data-alert-id="${alertId}"]`);
        if (alertItem) {
            alertItem.classList.add('selected');
        }
        
        // Auto-mark alert as read when selected
        await markAlertAsRead(alertId);
        
        window.location.href = `/alerts/${alertId}`;
    }

    // Mark single alert as read
    async function markAlertAsRead(alertId) {
        try {
            const response = await fetch(`/api/alerts/${alertId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: 'read' })
            });
            
            if (response.ok) {
                // Update the alert in our local data
                const alert = alerts.find(a => a.id == alertId);
                if (alert) {
                    alert.status = 'read';
                }
                
                // Update the UI to reflect the status change
                const alertElement = document.querySelector(`[data-alert-id="${alertId}"]`);
                if (alertElement) {
                    alertElement.classList.remove('unread');
                    alertElement.classList.add('read');
                }
                
                // Update counts
                loadAlertCounts();
                updateStats();
                
                console.log(`✅ Marked alert ${alertId} as read`);
            } else {
                console.error('Failed to mark alert as read:', response.statusText);
            }
        } catch (error) {
            console.error('Error marking alert as read:', error);
        }
    }

    // Bulk actions
    async function markAllAsRead() {
        try {
            showAlert('info', 'Marking all alerts as read...');
            
            const response = await fetch('/api/alerts/mark-read-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            if (response.ok) {
                const result = await response.json();
                showAlert('success', `✅ ${result.message}`);
                
                // Update local data
                alerts.forEach(alert => {
                    if (alert.status === 'unread' || !alert.status) {
                        alert.status = 'read';
                    }
                });
                
                // Refresh displays
                loadAlerts();
                loadAlertCounts();
            } else {
                const error = await response.json();
                showAlert('error', `❌ Error: ${error.error}`);
            }
        } catch (error) {
            console.error('Error marking alerts as read:', error);
            showAlert('error', '❌ Failed to mark alerts as read');
        }
    }

    async function dismissAllVisible() {
        if (filteredAlerts.length === 0) {
            showAlert('warning', 'No alerts to dismiss');
            return;
        }
        
        const confirmed = confirm(`Are you sure you want to dismiss ${filteredAlerts.length} visible alerts?`);
        if (!confirmed) return;
        
        try {
            showAlert('info', `Dismissing ${filteredAlerts.length} alerts...`);
            
            const alertIds = filteredAlerts.map(alert => alert.id);
            const response = await fetch('/api/alerts/dismiss-multiple', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ alert_ids: alertIds })
            });
            
            if (response.ok) {
                const result = await response.json();
                showAlert('success', `✅ ${result.message}`);
                
                // Update local data
                alertIds.forEach(id => {
                    const alert = alerts.find(a => a.id === id);
                    if (alert) {
                        alert.status = 'dismissed';
                    }
                });
                
                // Refresh displays
                loadAlerts();
                loadAlertCounts();
            } else {
                const error = await response.json();
                showAlert('error', `❌ Error: ${error.error}`);
            }
        } catch (error) {
            console.error('Error dismissing alerts:', error);
            showAlert('error', '❌ Failed to dismiss alerts');
        }
    }

    // Add functions for marking visible alerts as read
    async function markVisibleAsRead() {
        if (filteredAlerts.length === 0) {
            showAlert('warning', 'No alerts to mark as read');
            return;
        }
        
        const unreadVisible = filteredAlerts.filter(alert => alert.status === 'unread' || !alert.status);
        if (unreadVisible.length === 0) {
            showAlert('info', 'All visible alerts are already read');
            return;
        }
        
        try {
            showAlert('info', `Marking ${unreadVisible.length} alerts as read...`);
            
            const alertIds = unreadVisible.map(alert => alert.id);
            const response = await fetch('/api/alerts/bulk-status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ alert_ids: alertIds, status: 'read' })
            });
            
            if (response.ok) {
                const result = await response.json();
                showAlert('success', `✅ Marked ${result.updated_count} alerts as read`);
                
                // Update local data
                alertIds.forEach(id => {
                    const alert = alerts.find(a => a.id === id);
                    if (alert) {
                        alert.status = 'read';
                    }
                });
                
                // Refresh displays
                loadAlerts();
                loadAlertCounts();
            } else {
                const error = await response.json();
                showAlert('error', `❌ Error: ${error.error}`);
            }
        } catch (error) {
            console.error('Error marking alerts as read:', error);
            showAlert('error', '❌ Failed to mark alerts as read');
        }
    }

    // Populate rule filter with URL parameter support
    function populateRuleFilter() {
        const ruleFilter = document.getElementById('ruleFilter');
        if (!ruleFilter) return;
        
        const rules = [...new Set(alerts.map(alert => alert.rule))].sort();
        const currentValue = ruleFilter.value;
        
        ruleFilter.innerHTML = '<option value="all">All Rules</option>';
        rules.forEach(rule => {
            const option = document.createElement('option');
            option.value = rule;
            option.textContent = rule;
            ruleFilter.appendChild(option);
        });
        
        // Set rule filter from URL parameter if provided
        if (currentFilters.rule !== 'all') {
            ruleFilter.value = currentFilters.rule;
        } else {
            ruleFilter.value = currentValue;
        }
    }



    // Update URL parameters without refreshing the page
    function updateURLParameters() {
        const params = new URLSearchParams();
        
        if (currentFilters.timeRange !== '7d') params.append('time_range', currentFilters.timeRange);
        if (currentFilters.priority !== 'all') params.append('priority', currentFilters.priority);
        if (currentFilters.rule) params.append('rule', currentFilters.rule);
        if (currentFilters.status !== 'all') params.append('status', currentFilters.status);
        if (currentFilters.limit !== '25') params.append('limit', currentFilters.limit);
        if (currentFilters.container) params.append('container', currentFilters.container);
        if (currentFilters.source) params.append('source', currentFilters.source);
        if (currentFilters.output) params.append('output', currentFilters.output);
        if (currentFilters.aiAnalysis !== 'all') params.append('ai_analysis', currentFilters.aiAnalysis);
        
        const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
        window.history.pushState({}, '', newUrl);
    }

    // Load alert counts
    async function loadAlertCounts() {
        try {
            const response = await fetch('/api/alerts/counts');
            if (response.ok) {
                const counts = await response.json();
                updateAlertCountElements(counts);
            } else {
                console.error('Failed to load alert counts:', response.statusText);
            }
        } catch (error) {
            console.error('Error loading alert counts:', error);
        }
    }

    // Update alert count elements
    function updateAlertCountElements(counts) {
        const elements = {
            'unreadCount': counts.unread,
            'readCount': counts.read,
            'dismissedCount': counts.dismissed,
            'totalCountControl': counts.total
        };
        
        Object.entries(elements).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });
    }

    // Update filter status indicator
    function updateFilterStatus() {
        const filterStatusEl = document.getElementById('filterStatus');
        if (!filterStatusEl) return;
        
        // Count active filters
        let activeFilters = 0;
        const filterLabels = [];
        
        if (currentFilters.timeRange !== 'all' && currentFilters.timeRange !== '7d') {
            activeFilters++;
            filterLabels.push(`Time: ${currentFilters.timeRange}`);
        }
        if (currentFilters.priority !== 'all') {
            activeFilters++;
            filterLabels.push(`Priority: ${currentFilters.priority}`);
        }
        if (currentFilters.status !== 'all') {
            activeFilters++;
            filterLabels.push(`Status: ${currentFilters.status}`);
        }
        if (currentFilters.rule) {
            activeFilters++;
            filterLabels.push(`Rule: ${currentFilters.rule}`);
        }
        if (currentFilters.container) {
            activeFilters++;
            filterLabels.push(`Container: ${currentFilters.container}`);
        }
        if (currentFilters.source) {
            activeFilters++;
            filterLabels.push(`Source: ${currentFilters.source}`);
        }
        if (currentFilters.output) {
            activeFilters++;
            filterLabels.push(`Content: ${currentFilters.output}`);
        }
        if (currentFilters.aiAnalysis !== 'all') {
            activeFilters++;
            filterLabels.push(`AI: ${currentFilters.aiAnalysis}`);
        }
        if (currentFilters.limit !== '25') {
            activeFilters++;
            filterLabels.push(`Limit: ${currentFilters.limit}`);
        }
        
        // Update status display
        if (activeFilters === 0) {
            filterStatusEl.textContent = 'No filters active';
            filterStatusEl.className = 'filter-count';
        } else {
            filterStatusEl.textContent = `${activeFilters} filter${activeFilters > 1 ? 's' : ''} active`;
            filterStatusEl.className = 'filter-count active';
            filterStatusEl.title = filterLabels.join(', ');
        }
        
        // Update filter group styling
        updateFilterGroupStyling();
    }

    // Update filter group styling to show which have values
    function updateFilterGroupStyling() {
        const filterInputs = document.querySelectorAll('.filter-input, .filter-select');
        filterInputs.forEach(input => {
            const filterGroup = input.closest('.filter-group');
            if (input.value && input.value !== 'all' && input.value !== '7d' && input.value !== '25') {
                filterGroup.classList.add('has-value');
            } else {
                filterGroup.classList.remove('has-value');
            }
        });
    }

    // Reset filters to default
    function resetFilters() {
        try {
            console.log('Resetting Dashboard filters');
            
            // Reset form elements
            const timeRangeEl = document.getElementById('timeRange');
            const priorityFilterEl = document.getElementById('priorityFilter');
            const statusFilterEl = document.getElementById('statusFilter');
            const limitFilterEl = document.getElementById('limitFilter');
            const ruleFilterEl = document.getElementById('ruleFilter');
            const containerFilterEl = document.getElementById('containerFilter');
            const sourceFilterEl = document.getElementById('sourceFilter');
            const outputFilterEl = document.getElementById('outputFilter');
            const aiAnalysisFilterEl = document.getElementById('aiAnalysisFilter');
            
            // Reset select elements
            if (timeRangeEl) timeRangeEl.value = '7d';
            if (priorityFilterEl) priorityFilterEl.value = 'all';
            if (statusFilterEl) statusFilterEl.value = 'all';
            if (limitFilterEl) limitFilterEl.value = '25';
            if (aiAnalysisFilterEl) aiAnalysisFilterEl.value = 'all';
            
            // Reset text inputs
            if (ruleFilterEl) ruleFilterEl.value = '';
            if (containerFilterEl) containerFilterEl.value = '';
            if (sourceFilterEl) sourceFilterEl.value = '';
            if (outputFilterEl) outputFilterEl.value = '';
            
            // Reset current filters object
            currentFilters = {
                timeRange: '7d',
                priority: 'all',
                rule: '',
                status: 'all',
                limit: '25',
                container: '',
                source: '',
                output: '',
                aiAnalysis: 'all'
            };
            
            // Apply default filters
            applyFilters();
            
        } catch (error) {
            console.error('Error resetting filters:', error);
        }
    }

    // Save filter configuration
    function saveFilter() {
        const filterConfig = {
            name: prompt('Enter a name for this filter configuration:'),
            filters: { ...currentFilters },
            timestamp: Date.now()
        };
        
        if (!filterConfig.name) return;
        
        // Save to localStorage
        const savedFilters = JSON.parse(localStorage.getItem('falco_dashboard_saved_filters') || '[]');
        savedFilters.push(filterConfig);
        localStorage.setItem('falco_dashboard_saved_filters', JSON.stringify(savedFilters));
        
        // Show success message
        showAlert('success', `Filter "${filterConfig.name}" saved successfully!`);
    }

    // Show alert function
    function showAlert(type, message) {
        // Create alert element
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible`;
        alertDiv.style.position = 'fixed';
        alertDiv.style.top = '20px';
        alertDiv.style.right = '20px';
        alertDiv.style.zIndex = '9999';
        alertDiv.style.minWidth = '300px';
        alertDiv.style.maxWidth = '500px';
        
        alertDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px;">
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                <span>${message}</span>
                <button type="button" class="btn-close" onclick="this.parentElement.parentElement.remove()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        
        // Add to page
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (alertDiv.parentElement) {
                alertDiv.remove();
            }
        }, 5000);
    }

    // ENHANCED KEYBOARD SHORTCUTS & NAVIGATION
    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', function(event) {
            // Don't interfere with form inputs
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }

            const key = event.key.toLowerCase();
            const alertItems = document.querySelectorAll('.alert-item');

            switch (key) {
                case 'r':
                    event.preventDefault();
                    if (focusedAlertIndex >= 0 && focusedAlertIndex < filteredAlerts.length) {
                        markAlertAsReadByIndex(focusedAlertIndex);
                    } else if (alertItems.length > 0) {
                        // Mark first alert if none focused
                        focusedAlertIndex = 0;
                        updateAlertFocus();
                        markAlertAsReadByIndex(0);
                    }
                    break;

                case 'd':
                    event.preventDefault();
                    if (focusedAlertIndex >= 0 && focusedAlertIndex < filteredAlerts.length) {
                        dismissAlertByIndex(focusedAlertIndex);
                    } else if (alertItems.length > 0) {
                        // Dismiss first alert if none focused
                        focusedAlertIndex = 0;
                        updateAlertFocus();
                        dismissAlertByIndex(0);
                    }
                    break;

                case 'arrowup':
                    event.preventDefault();
                    if (alertItems.length > 0) {
                        focusedAlertIndex = Math.max(0, focusedAlertIndex - 1);
                        updateAlertFocus();
                    }
                    break;

                case 'arrowdown':
                    event.preventDefault();
                    if (alertItems.length > 0) {
                        focusedAlertIndex = Math.min(alertItems.length - 1, focusedAlertIndex + 1);
                        updateAlertFocus();
                    }
                    break;

                case 'enter':
                    event.preventDefault();
                    if (focusedAlertIndex >= 0 && focusedAlertIndex < filteredAlerts.length) {
                        const alert = filteredAlerts[focusedAlertIndex];
                        selectAlert(alert.id);
                    }
                    break;

                case 'escape':
                    event.preventDefault();
                    clearAlertFocus();
                    break;

                case '?':
                    event.preventDefault();
                    toggleKeyboardHint();
                    break;
            }
        });

        // Show shortcuts hint on first focus
        document.addEventListener('focusin', function(event) {
            if (event.target.classList.contains('alert-item')) {
                showKeyboardHint();
            }
        });
    }

    // Update alert focus state
    function updateAlertFocus() {
        const alertItems = document.querySelectorAll('.alert-item');
        
        alertItems.forEach((item, index) => {
            item.classList.remove('focused');
            if (index === focusedAlertIndex) {
                item.classList.add('focused');
                item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        });
    }

    // Clear alert focus
    function clearAlertFocus() {
        focusedAlertIndex = -1;
        document.querySelectorAll('.alert-item').forEach(item => {
            item.classList.remove('focused');
        });
    }

    // Mark alert as read by index
    async function markAlertAsReadByIndex(index) {
        if (index >= 0 && index < filteredAlerts.length) {
            const alert = filteredAlerts[index];
            const alertElement = document.querySelector(`[data-alert-id="${alert.id}"]`);
            
            if (alertElement && alert.status !== 'read') {
                // Add animation class
                alertElement.classList.add('status-changing');
                
                await markAlertAsRead(alert.id);
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    alertElement.classList.remove('status-changing');
                }, 500);
                
                showAlert('success', `✓ Alert marked as read`);
            }
        }
    }

    // Dismiss alert by index
    async function dismissAlertByIndex(index) {
        if (index >= 0 && index < filteredAlerts.length) {
            const alert = filteredAlerts[index];
            const alertElement = document.querySelector(`[data-alert-id="${alert.id}"]`);
            
            if (alertElement && alert.status !== 'dismissed') {
                // Add animation class
                alertElement.classList.add('status-changing');
                
                await dismissAlert(alert.id);
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    alertElement.classList.remove('status-changing');
                }, 500);
                
                showAlert('success', `✓ Alert dismissed`);
            }
        }
    }

    // Dismiss single alert
    async function dismissAlert(alertId) {
        try {
            const response = await fetch(`/api/alerts/${alertId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: 'dismissed' })
            });
            
            if (response.ok) {
                // Update the alert in our local data
                const alert = alerts.find(a => a.id == alertId);
                if (alert) {
                    alert.status = 'dismissed';
                }
                
                // Update the UI to reflect the status change
                const alertElement = document.querySelector(`[data-alert-id="${alertId}"]`);
                if (alertElement) {
                    alertElement.classList.remove('unread', 'read');
                    alertElement.classList.add('dismissed');
                }
                
                // Update counts
                loadAlertCounts();
                updateStats();
                
                console.log(`✅ Dismissed alert ${alertId}`);
            } else {
                console.error('Failed to dismiss alert:', response.statusText);
            }
        } catch (error) {
            console.error('Error dismissing alert:', error);
        }
    }

    // REAL-TIME UPDATES WITH SERVER-SENT EVENTS
    function initializeRealTimeUpdates() {
        console.log('🔄 Initializing real-time updates...');
        
        // Check if browser supports EventSource
        if (typeof EventSource !== 'undefined') {
            connectToEventStream();
        } else {
            console.warn('⚠️ Browser does not support Server-Sent Events');
            updateRealTimeIndicator(false, 'Not supported');
        }
    }

    function connectToEventStream() {
        try {
            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/events/stream');
            
            eventSource.onopen = function(event) {
                console.log('✅ Real-time connection established');
                realTimeConnected = true;
                updateRealTimeIndicator(true, 'Connected');
            };

            eventSource.onmessage = function(event) {
                console.log('📡 Received real-time update:', event.data);
                
                try {
                    const data = JSON.parse(event.data);
                    handleRealTimeUpdate(data);
                } catch (error) {
                    console.error('Error parsing real-time update:', error);
                }
            };

            eventSource.onerror = function(event) {
                console.error('❌ Real-time connection error:', event);
                realTimeConnected = false;
                updateRealTimeIndicator(false, 'Disconnected');
                
                // Attempt to reconnect after 5 seconds
                setTimeout(() => {
                    if (!realTimeConnected) {
                        console.log('🔄 Attempting to reconnect...');
                        connectToEventStream();
                    }
                }, 5000);
            };

            eventSource.addEventListener('alert_status_change', function(event) {
                console.log('📊 Alert status change:', event.data);
                const data = JSON.parse(event.data);
                handleAlertStatusChange(data);
            });

            eventSource.addEventListener('new_alert', function(event) {
                console.log('🚨 New alert received:', event.data);
                const data = JSON.parse(event.data);
                handleNewAlert(data);
            });

        } catch (error) {
            console.error('❌ Failed to establish real-time connection:', error);
            updateRealTimeIndicator(false, 'Failed');
        }
    }

    function handleRealTimeUpdate(data) {
        switch (data.type) {
            case 'alert_status_change':
                handleAlertStatusChange(data);
                break;
            case 'new_alert':
                handleNewAlert(data);
                break;
            case 'counts_updated':
                loadAlertCounts();
                break;
            default:
                console.log('🔔 Unknown real-time update type:', data.type);
        }
    }

    function handleAlertStatusChange(data) {
        const { alert_id, new_status, old_status } = data;
        
        // Update local data
        const alert = alerts.find(a => a.id == alert_id);
        if (alert) {
            alert.status = new_status;
        }
        
        // Update UI
        const alertElement = document.querySelector(`[data-alert-id="${alert_id}"]`);
        if (alertElement) {
            alertElement.classList.remove('unread', 'read', 'dismissed');
            alertElement.classList.add(new_status, 'newly-updated');
            
            // Remove the update animation after it completes
            setTimeout(() => {
                alertElement.classList.remove('newly-updated');
            }, 1000);
        }
        
        // Update counts
        updateStats();
        loadAlertCounts();
        
        console.log(`📊 Alert ${alert_id} status changed: ${old_status} → ${new_status}`);
    }

    function handleNewAlert(data) {
        const { alert } = data;
        
        // Add to alerts array
        alerts.unshift(alert);
        
        // Refresh display if it matches current filters
        applyFilters();
        
        // Update counts
        updateStats();
        loadAlertCounts();
        
        console.log(`🚨 New alert added: ${alert.rule}`);
        
        // Show notification for critical alerts
        if (alert.priority === 'critical') {
            showAlert('warning', `🚨 New critical alert: ${alert.rule}`);
        }
    }

    function updateRealTimeIndicator(connected, status) {
        const indicator = document.getElementById('realTimeIndicator');
        const statusSpan = document.getElementById('realTimeStatus');
        
        if (indicator && statusSpan) {
            statusSpan.textContent = status;
            
            if (connected) {
                indicator.classList.add('connected');
                indicator.classList.remove('disconnected');
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
            }
        }
    }

    // KEYBOARD SHORTCUTS HINT MANAGEMENT
    function showKeyboardHint() {
        const hint = document.getElementById('keyboardHint');
        if (hint) {
            hint.classList.add('show');
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                hint.classList.remove('show');
            }, 3000);
        }
    }

    function toggleKeyboardHint() {
        const hint = document.getElementById('keyboardHint');
        if (hint) {
            hint.classList.toggle('show');
        }
    }

    // ENHANCED ALERT SELECTION WITH ANIMATION
    async function selectAlert(alertId) {
        // Remove previous selection
        document.querySelectorAll('.alert-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        
        const alertItem = document.querySelector(`[data-alert-id="${alertId}"]`);
        if (alertItem) {
            alertItem.classList.add('selected');
            
            // Update focused index
            const index = parseInt(alertItem.getAttribute('data-alert-index'));
            if (!isNaN(index)) {
                focusedAlertIndex = index;
                updateAlertFocus();
            }
        }
        
        // Auto-mark alert as read when selected (with animation)
        const alert = alerts.find(a => a.id == alertId);
        if (alert && alert.status !== 'read') {
            if (alertItem) {
                alertItem.classList.add('status-changing');
            }
            
            await markAlertAsRead(alertId);
            
            if (alertItem) {
                setTimeout(() => {
                    alertItem.classList.remove('status-changing');
                }, 500);
            }
        }
        
        window.location.href = `/alerts/${alertId}`;
    }

    // ENHANCED MARK AS READ WITH BETTER UI FEEDBACK
    async function markAlertAsRead(alertId) {
        try {
            const response = await fetch(`/api/alerts/${alertId}/status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: 'read' })
            });
            
            if (response.ok) {
                // Update the alert in our local data
                const alert = alerts.find(a => a.id == alertId);
                if (alert && alert.status !== 'read') {
                    alert.status = 'read';
                    
                    // Update the UI to reflect the status change
                    const alertElement = document.querySelector(`[data-alert-id="${alertId}"]`);
                    if (alertElement) {
                        alertElement.classList.remove('unread');
                        alertElement.classList.add('read');
                    }
                    
                    // Update counts
                    loadAlertCounts();
                    updateStats();
                    
                    console.log(`✅ Marked alert ${alertId} as read`);
                }
            } else {
                console.error('Failed to mark alert as read:', response.statusText);
                showAlert('error', 'Failed to mark alert as read');
            }
        } catch (error) {
            console.error('Error marking alert as read:', error);
            showAlert('error', 'Error marking alert as read');
        }
    }

    // Apply filter from stat card with enhanced feedback
    function applyStatFilter(filterType, event) {
        if (event) {
            event.preventDefault();
        }
        
        console.log(`🎯 Applying stat filter: ${filterType}`);
        
        // Reset filters first
        resetFilters();
        
        // Apply the specific filter
        switch (filterType) {
            case 'critical':
                document.getElementById('priorityFilter').value = 'critical';
                currentFilters.priority = 'critical';
                break;
            case 'unread':
                document.getElementById('statusFilter').value = 'unread';
                currentFilters.status = 'unread';
                break;
            case 'recent':
                document.getElementById('timeRange').value = '1h';
                currentFilters.timeRange = '1h';
                break;
            case 'all':
            default:
                // Already reset, show all
                break;
        }
        
        // Apply filters and show feedback
        applyFilters();
        showAlert('info', `📊 Filtered to ${filterType} alerts`);
    }

    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
        if (eventSource) {
            eventSource.close();
        }
    });
</script>
{% endblock %}